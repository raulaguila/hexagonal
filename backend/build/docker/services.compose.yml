name: api

volumes:

  postgres_volume:
    name: postgres_volume_api
  minio_volume:
    name: minio_volume_api
  elastcsearch_volume:
    name: elastcsearch_volume_api

networks:

  network_api:
    name: network_api
    driver: bridge

services:

  postgres:

    hostname: postgres
    container_name: api_postgres
    image: api_postgres
    build:
      context: ./postgres
      dockerfile: Dockerfile
    # image: postgres:17.2-alpine
    restart: always
    volumes:
      - postgres_volume:/var/lib/postgresql/data
      # - ../db/SQL/:/docker-entrypoint-initdb.d
    command: >
      postgres
      -p ${POSTGRES_PORT}
      -c shared_preload_libraries='pg_cron'
      -c cron.database_name='${POSTGRES_BASE}'
    ports:
      - ${POSTGRES_PORT}:${POSTGRES_PORT}
    environment:
      - TZ=${TZ}
      - POSTGRES_DB=${POSTGRES_BASE}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASS}
    healthcheck:
      test: [ "CMD-SHELL", "sh -c 'pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_BASE} -p ${POSTGRES_PORT}'" ]
      interval: 2s
      timeout: 5s
      retries: 15
      start_period: 1s
      start_interval: 2s
    networks:
      - network_api

  redis:
    hostname: redis
    container_name: api_redis
    image: redis:8.4-alpine
    restart: always
    ports:
      - ${REDIS_PORT}:${REDIS_PORT}
    environment:
      - TZ=${TZ}
      - REDIS_PASS=${REDIS_PASS}
    command: redis-server --save 60 10 --loglevel warning --requirepass ${REDIS_PASS} --port ${REDIS_PORT} --bind 0.0.0.0
    healthcheck:
      test: [ "CMD-SHELL", "redis-cli -u redis://${REDIS_PASS}@localhost:${REDIS_PORT} ping" ]
      interval: 5s
      timeout: 3s
      retries: 5
    networks:
      - network_api
  
  minio:

    hostname: minio
    container_name: api_minio
    image: bitnamilegacy/minio:2024
    restart: always
    volumes:
      - minio_volume:/bitnami/minio/data
    ports:
      - ${MINIO_API_PORT}:${MINIO_API_PORT}
      - ${MINIO_WEB_PORT}:${MINIO_WEB_PORT}
    environment:
      - TZ=${TZ}
      - MINIO_ROOT_USER=${MINIO_USER}
      - MINIO_ROOT_PASSWORD=${MINIO_PASS}
      - MINIO_API_PORT_NUMBER=${MINIO_API_PORT}
      - MINIO_CONSOLE_PORT_NUMBER=${MINIO_WEB_PORT}
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:9004/minio/health/live || exit 1"]
      interval: 2s
      timeout: 5s
      retries: 15
      start_period: 1s
      start_interval: 2s
    networks:
      - network_api

  # elasticsearch:

  #   hostname: elasticsearch
  #   container_name: api_elasticsearch
  #   image: docker.elastic.co/elasticsearch/elasticsearch:8.12.0
  #   restart: always
  #   environment:
  #     - TZ=${TZ}
  #     - discovery.type=single-node
  #     - ES_JAVA_OPTS=-Xms512m -Xmx512m
  #     - xpack.security.enabled=true
  #     - xpack.security.authc.api_key.enabled=true
  #     - ELASTIC_PASSWORD=${ELASTIC_PASS}
  #     - xpack.monitoring.collection.enabled=true
  #   ulimits:
  #     memlock:
  #       soft: -1
  #       hard: -1
  #   mem_limit: 1g
  #   ports:
  #     - ${ELASTICSEARCH_PORT}:${ELASTICSEARCH_PORT}
  #   healthcheck:
  #     test: ["CMD-SHELL", "curl -u ${ELASTIC_USER}:${ELASTIC_PASS} -f http://localhost:${ELASTICSEARCH_PORT}/_cluster/health || exit 1"]
  #     interval: 5s
  #     timeout: 10s
  #     retries: 10
  #     start_period: 30s
  #   networks:
  #     - network_api
    
  # kibana:

  #   hostname: kibana
  #   container_name: api_kibana
  #   image: docker.elastic.co/kibana/kibana:8.12.0
  #   restart: always
  #   environment:
  #     - TZ=${TZ}
  #     - ELASTICSEARCH_HOSTS=http://elasticsearch:${ELASTICSEARCH_PORT}
  #     - ELASTICSEARCH_USERNAME=${KIBANA_SYSTEM_USER}
  #     - ELASTICSEARCH_PASSWORD=${KIBANA_SYSTEM_PASS}
  #     - xpack.security.enabled=true
  #   ports:
  #     - ${KIBANA_PORT}:${KIBANA_PORT}
  #   depends_on:
  #     es-setup:
  #       condition: service_completed_successfully
  #     elasticsearch:
  #       condition: service_healthy
  #   healthcheck:
  #     test: ["CMD-SHELL", "curl -u ${ELASTIC_USER}:${ELASTIC_PASS} -f http://localhost:${KIBANA_PORT}/api/status || exit 1"]
  #     interval: 10s
  #     timeout: 5s
  #     retries: 20
  #     start_period: 30s
  #   networks:
  #     - network_api
  
  # apm-server:

  #   hostname: apm-server
  #   container_name: api_apm-server
  #   image: docker.elastic.co/apm/apm-server:8.12.0
  #   restart: always
  #   environment:
  #     - apm-server.host=0.0.0.0:8200
  #   command: >
  #     apm-server -e
  #     -E output.elasticsearch.hosts=["http://elasticsearch:${ELASTICSEARCH_PORT}"]
  #     -E output.elasticsearch.username=${ELASTIC_USER}
  #     -E output.elasticsearch.password=${ELASTIC_PASS}
  #     -E setup.kibana.host=http://kibana:${KIBANA_PORT}
  #     -E setup.kibana.username=${ELASTIC_USER}
  #     -E setup.kibana.password=${ELASTIC_PASS}
  #   ports:
  #     - ${APM_PORT}:${APM_PORT}
  #   depends_on:
  #     elasticsearch:
  #       condition: service_healthy
  #     kibana:
  #       condition: service_healthy
  #     apm-setup:
  #       condition: service_completed_successfully
  #   networks:
  #     - network_api
  
  # otel-collector:

  #   hostname: otel-collector
  #   container_name: api_otel-collector
  #   image: otel/opentelemetry-collector:0.89.0
  #   restart: always
  #   volumes:
  #     - ../../config/otel-collector-config.yml:/etc/otel-collector-config.yml
  #   command: ["--config", "/etc/otel-collector-config.yml"]
  #   ports:
  #     - ${OTLP_GRPC_PORT}:${OTLP_GRPC_PORT}
  #     - ${OTLP_HTTP_PORT}:${OTLP_HTTP_PORT}
  #     - 55681:55681
  #   depends_on:
  #     elasticsearch:
  #       condition: service_healthy
  #   networks:
  #     - network_api

  # apm-setup:
  #   image: curlimages/curl
  #   depends_on:
  #     kibana:
  #       condition: service_healthy
  #   command: >
  #     /bin/sh -c "
  #       echo 'Waiting for Kibana...';
  #       until curl -f -s http://kibana:${KIBANA_PORT}/api/status; do
  #         sleep 5;
  #       done;
  #       echo 'Installing APM integration...';
  #       curl -u ${ELASTIC_USER}:${ELASTIC_PASS} -X POST -H 'kbn-xsrf: true' -H 'Content-Type: application/json' http://kibana:${KIBANA_PORT}/api/fleet/epm/packages/apm/8.12.0;
  #     "
  #   networks:
  #     - network_api

  # es-setup:
  #   image: curlimages/curl
  #   restart: "no"
  #   depends_on:
  #     elasticsearch:
  #       condition: service_healthy
  #   command: >
  #     /bin/sh -c "
  #       echo 'Waiting for Elasticsearch...';
  #       until curl -u ${ELASTIC_USER}:${ELASTIC_PASS} -s http://elasticsearch:${ELASTICSEARCH_PORT}/_cluster/health; do
  #         sleep 1;
  #       done;
  #       echo 'Setting kibana_system password...';
  #       curl -u ${ELASTIC_USER}:${ELASTIC_PASS} -X POST -H 'Content-Type: application/json' http://elasticsearch:${ELASTICSEARCH_PORT}/_security/user/${KIBANA_SYSTEM_USER}/_password -d '{\"password\":\"${KIBANA_SYSTEM_PASS}\"}';
  #     "
  #   networks:
  #     - network_api